# 7. Operating-System Design and Implementation

1. Design Goals
2. Mechanisms and Policies
3. System Implementation

---

OS를 설계하고, 구현하는 방법에 대해 알아보자.  
설계, 구현 방법에 완벽한 방법은 없으나, 좋은 접근 방법들이 존재한다.

## 1. Design Goals

- 시스템의 목표와 사양을 정의하는 것
- 목표를 정확히 정의할 수 없음, 애매함
- user goal, system goal
- user goal <sup>사용자 관점</sup>
    - 사용하기 쉽고, 신뢰성 있고, 안정적이고, 빠르게 동작
- system goal <sup>시스템 관점, OS 개발자 관점</sup>
    - 설계, 구현, 유지보수가 쉽고, 신뢰성이 있고, 오류가 없어야 함

## 2. Mechanisms and Policies

- 메커니즘으로부터 정책을 도출해내는 것
- 메커니즘 : 문제를 해결하는 방법
- 정책 : 메커니즘을 적용하는 방법
    - ex. timer
        - 메커니즘 : timer를 통해 CPU를 보호하는 것
        - 정책 : 어떤 사용자에게 얼마만큼의 타이머를 할당할 것인가
- 정책은 장소나 시간에 따라 변할 수 있음
- 정책 마다 메커니즘의 변경을 최소화해야함
    - ex. 정책 변경시 메커니즘의 특정 매개변수만 재정의
- Linux
    - 오픈소스 OS로 다양한 범위의 컴퓨터에서 사용됨
    - 표준 리눅스 커널은 CPU 스케쥴링 메커니즘을 가짐
    - 이 메커니즘은 다른 정책들이 적절히 수정하여 사용할 수 있음

## 3. System Implementation

- OS는 긴시간동안 다양한 사람들에 의해 수정되어와서
    - OS의 일반적인 구현방법을 정의하긴 힘듦
- 커널의 하위레벨 : 어셈블리어, C
- 상위 레벨 : C, C++, ...

### higher-level 언어로 OS 구현하기

- 장점
    - 프로그래밍이 쉬움, 간결함, 이해하기 쉽고, 디버깅이 쉬움
    - 컴파일러 기술이 발전
    - 다른 하드웨어와 연동하기 쉬움
        - 작은 임베디드, Intel x86, Arm chips 등
- 단점
    - 속도를 느리게 함
    - 스토리지 공간을 많이 차지함
- 다른 시스템에서는 어셈블리어 코드보다 higher-level 언어 코드가 장점이 많음
    - 자료구조, 알고리즘 구현능력 면에서