# 5. Resource Management

1. [process Management](#1-process-management)
2. [Memory Management](#2-memory-management)
3. [File-System Management](#3-file-system-management)
4. [Mass-Storage Management](#4-mass-storage-management)
5. [Cache Management](#5-cache-management)
6. [I/O System Management](#6-io-system-management)

OS는 아래와 같은 리소스의 관리자이다.  
리소스는 CPU, 메모리, I/O 장치, 파일, 캐시, 저장장치 등이 있다.

## 1. Process Management

### process : program in execution

- CPU에 실행되지 않으면 프로그램은 어떤 명령도 실행할 수 없음
- 프로세스 : 실행 상태의 프로그램
    - e.g. 컴파일러, 워드 프로세스, SNS 앱
- 프로세스가 서브 프로세스를 동시에 실행 가능
- 프로세스는 실행 중 특정 리소스가 필요
- 실행 중인 프로세스에게 리소스를 할당
    - 리소스는 시스템 자원 뿐 아니라, 데이터 입력일 수도 있음
        - e.g. 웹 브라우저 프로세스의 URL input
- 사용자 프로세스, 시스템 프로세스로 나뉨

### Program Counter <sup>PC</sup>

- program counter : 다음 실행할 명령을 가리킴
- 싱글 스레드 프로세스
    - 하나의 PC를 가짐
    - 명령 실행이 순차적
    - 프로세스 안에서 동시에 최대 하나의 명령 실행 가능
    - 하나의 프로그램에 2가지의 프로세스가 연관되어 있어도 별개로 간주, 동시 실행 불가
- 멀티 스레드 프로세스
    - 2개 이상의 PC
    - 각 PC가 각 스레드에 위치하여 다음 실행 명령 줄을 가리킴
- 프로세스 동시 실행
    - 싱글 코어 : 다중화
    - 멀티 코어 : 병렬화

### process 에 대한 OS의 책임

- 사용자/시스템 프로세스를 생성, 제거
- 프로세스와 스레드를 CPU에 스케쥴링
- 프로세스의 실행 / 중지
- 프로세스 동기화 메커니즘 제공
- 프로세스 간 통신 메커니즘 제공

## 2. Memory Management

### main memory

- 컴퓨터 시스템 명령의 중심
- 아주 큰 바이트 배열
- 각 바이트에는 고유 주소 있음
- CPU와 I/O 장치가 공유한 데이터를 저장, 빠르게 접근
- CPUI가 직접 주소를 지정하고 접근할 수 있는 유일한 대형 저장 장치
    - disk에 있는 데이터를 읽을 떄에도 메인 메모리에 로딩 후 읽음
    - 명령을 실행하기 위해서는 명령을 먼저 메모리에 로딩
- von Neumann 아키텍쳐
    - 메모리에서 명령을 읽고
    - 데이터를 메모리에 읽고 씀
- 프로그램 실행
    1. 절대 주소에 매핑되어 메모리에 로딩
    2. 프로그램이 실행되면 메모리의 주소를 통해 명령, 데이터에 접근
    3. 프로그램이 종료되면 해당 메모리 공간이 사용 가능상태로 선언되어 다른 프로그램 로딩 및 실행 가능

### 메모리 관리 필요성

- 여러 프로그램을 메모리에 유지해야함
- 다양한 방식 <sup>알고리즘</sup>의 메모리 관리 존재
- 시스템의 하드웨어 설계 고려

### memory 에 대한 프로세스의 책임

- 현재 사용중인 메모리 파트, 해당 파트를 사용하는 프로그램 추적
- 메모리 할당과 제거
- 어떤 프로세스를 메모리에 로딩하고 내릴지 결정

## 3. File-System Management

- oS는 파일 정보에 대한 논리적이고 통일된 뷰 제공
- 저장장치의 물리적인 정보를 논리적인 단위로 추상화
- 사용자는 여러 저장장치에 파일 저장 가능
- OS는 파일에 대한 디렉토리를 제공하여 사용성을 높임
- 사용자가 파일 사용시, 접근, 권한, read, write 등의 편의성 제공

### File-System 에 대한 프로세스의 책임

- 파일 생성, 삭제
- 파일을 디렉토리로 구성, 삭제
- 파일 <sup>디렉토리</sup>의 기본 조작 기능 지원
- 대용량 저장장치에 파일 매핑
- 안정적인 비활성 스토리지에 파일 백업

## 4. Mass-Storage Management

### secondary storage

- 대용량 저장장치, 메인 메모리의 백업
- e.g. HDD, Nonvolatile memory <sup>NVM</sup>, ...
- 대부분의 프로그램은 메인 메모리에 데이터를 로딩하기 전에 2차 저장장치에 저장
- OS의 성능은 대부분 2차 저장소의 속도에 의존

### secondary storage 에 대한 프로세스의 책임

- 마운트, 언마운트
- 빈 공간 관리
- 저장 공간 할당
- 디스크 스케쥴링
- 파티셔닝
- 보호

### Tertiary storage <sup>제 3의 저장 장치</sup>

- 2차 저장소보다 비용이 낮고, 속도가 느림
- e.g. 백업 디스크, 아카이빙 스토리지, bluray, ...

## 5. Cache Management

- 정보를 찾을 때, 제일 먼저 캐시를 확인하여 사용
- 캐시에 없다면 먼저 캐싱하고 사용 <sub>곧 다시 쓴다고 가정하여</sub>
- 내부의 프로그래밍 가능한 레지스터가 메인 메모리에게 고속 캐시를 제공
- 프로그래머 <sup>혹은 컴파일러</sup>가 어떤 레지스터에 할당, 교체 알고리즘 구현
    - 레지스터에 유지할 지, 메인 메모리에 유지할 지 결정
- 하드웨어 단의 캐시도 존재, OS 외부 영역

### 캐시의 용량 제한

<img src="img.png"  width="50%"/>

- 캐시는 용량이 제한되어 있기 때문에 관리가 필요함
- 사이즈, 대체 알고리즘 선정
- 저장 계층 간의 데이터 이동은 OS에게 명시적이거나 암묵적일 수 있음
    - 각 이동 경로 별로 제어권이 다르기 때문

### 데이터 캐싱 알고리즘

<img src="img_1.png"  width="50%"/>

1. 정수 A가 파일 B에 위치 (파일 B는 하드디스크에 있음)
2. A 증감 연산 시작
3. I/O : B의 정수 A 디스크 블록을 메인 메모리에 로드
4. A를 캐시와 레지스터에 복사
    - **이제부터 A는 여러 곳에 존재 <sub>하드디스크, 메인 메모리, 캐시, 레지스터</sub>**
5. 레지스터 내부 A 값 증감
    - 이제부터 각 위치마다 A 값이 다름
6. 레지스터에서 하드디스크까지 값 내려서 업데이트

### 캐시 동시성 문제

- 동시에 하나의 프로세스만 진행되는 환경에서는 문제 없음
    - 캐시의 접근이 가장 높은 계층에서만 이루어지기 때문
- 멀티 태스킹 환경
    - 각 프로세스가 가장 최신 캐시값에 접근하도록 주의 필요
- 멀티 프로세서 환경
    - cache coherence <sup>캐시 일관성</sup> 문제 발생
    - 코어마다 로컬 캐시 존재
- 분산 환경
    - 각 시스템별로 값이 분산

## 6. I/O System Management

- OS는 사용자로부터 하드웨어의 특성을 숨김
    - e.g. 유닉스는 I/O 장치를 I/O 서브 시스템에 의해 OS로부터 숨김
- I/O 서브 시스템
    - 메모리 관리 구성요소
    - 장치 드라이버 인터페이스
    - 특정 하드웨어 장치의 드라이버

