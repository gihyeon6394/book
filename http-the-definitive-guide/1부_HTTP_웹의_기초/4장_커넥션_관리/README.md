<h1>4장 커넥션 관리</h1>

>

- HTTP 커넥션과 그것이 어떻게 사용되는지
- TCP 커넥션의 지연, 병목, 막힘
- 병렬, keep-alive, 파이프라인 커넥션 을 활용한 HTTP 최적화
- 커넥션 관리 시 따라야하는 규칙들

<h2>contents</h2>

1. TCP 커넥션
   > HTTP 는 TCP 커넥션 계층 위에서 동작

    1. 신뢰할 수 있는 데이터 전송 통로인 TCP
       > TCP는 충돌 없이 순서에 맞게 HTTP 데이터들을 전송한다

    2. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다
       > TCP 세그먼트 단위로 잘게 쪼개고 IP 패킷 봉투에 담아서 인터넷을 통해 전달

    3. TCP 커넥션 유지하기
       > <**발신지/수신지 IP, 포트 번호**>로 유일한 TCP 커넥션을 생성  
       하나의 컴퓨터에 4개가 모두 동일한 커넥션은 하나만 존재

    4. TCP 소켓 프로그래밍
       > 소켓 API <sup>운영체제 제공</sup>를 사용하여   
       TCP endpoint를 만들고 서로 커넥션을 생성하여   
       데이터 스트림을 읽고 쓸 수 있음

2. TCP 성능에 대한 고려
    > TCP 커넥션을 알고 튜닝하여 HTTP 성능 향상 가능  
        튜닝시에는 **확신을 가질 정도로 잘 알고 수정할 것**  

    1. HTTP 트랜잭션 지연
       > 대부분의 HTTP 지연은 TCP 네트워크 지연 때문 <sup>응답 지연 등</sup>  
       
    2. 성능 관련 중요 요소
       > 고성능 HTTP 소프트웨어 개발자라면 알아야함  
        핸드셰이크, slow-start, Nagle 알고리즘, TIME_WAIT, 포트 고갈

    3. TCP 커넥션 핸드셰이크 지연
       > TCP 커넥션을 맺기위한 핸드셰이크   
       HTTP 데이터 자체가 작다면 전체 시간의 많은 비율을 핸드셰이크가 차지  
       **이미 맺어진 커넥션이 있다면 재활용하는 방법은 없을까?**

    4. 확인 응답 지연
       > 확인 응답을 **piggyback** <sup>편승</sup> 시키기 위해 기다림    
         지연 원인이나 관련 기능을 수정 가능  

    5. TCP 느린 시작 (slow start)
       > 확인응답에 따라 패킷 수를 늘려 줌 = 처음에는 느림  
         이미 맺어진<sup>튜닝된</sup> 커넥션을 재활용한다면 느린 시작을 건너뛸 수 있음 **<sup>지속 커넥션</sup>**

    6. Nagle (Nagle) 알고리즘과 TCP_NODELAY
        > 전송하기에 충분할 만큼 패킷 크기가 되야 전송  
          **TCP_NODELAY** 옵션을 사용하여 Nagle 알고리즘을 무시하고 바로 전송

    7. TIME_WAIT의 누적과 포트 고갈
       > 성능 측정 시에 TCP 커넥션의 유일 값 4 요소 때문에 문제 발생    
         2MSL 동안 새로운 커넥션을 못 맺는데,   
         2SML 안에 새로운 커넥션이 생성되야 할정도의 부하 성능을 측정하면 포트 고갈 발생
       
3. HTTP 커넥션 관리
    1. 흔히 잘못 이해하는 Connection 헤더
        > hop은 수신한 헤더를 모두 적용하고 다음 hop에 보낼 때 받은 헤더를 삭제한다

    2. 순차적인 트랜잭션 처리에 의한 지연
        > 물리적인 지연과 심리적인 지연 발생  

4. 병렬 커넥션
    > 물리/심리적으로 해소 가능하나 물리적으로 한계가 있음  
      사용자는 물리적 한계를 느끼지 못하고 빠르게 **느낄수도** 있음

    1. 병렬 커넥션은 페이지를 더 빠르게 내려받는다
        > 물리 / 심리적 지연 해소 

    2. 병렬 커넥션이 항상 더 빠르지는 않다
        > 대역폭이 좁으면 물리적 한계, 많은 커넥션은 서버 메모리 부하  
            보통 브라우저가 6~8개의 병렬 커넥션 맺음

    3. 병렬 커넥션은 더 빠르게 '느껴질 수' 있다
        > 사용자는 병렬적으로 로딩하는 걸 빠르게 **느낀다**

5. 지속 커넥션
    > 지속커넥션을 통해 TCP 커넥션의 단점을 극복 가능  
      단, dumb<sup>멍청한</sup> 프락시를 주의할 것
   
    1. 지속 커넥션 vs 병렬 커넥션
        > 웹 어플리케이션이 적은 수의 병렬 커넥션을 맺고 지속 커넥션으로서 유지

    2. HTTP/1.0+의 Keep-Alive 커넥션
        > 커넥션은 맺고 끊음에 시간 쓸 필요 없음

    3. Keep-Alive 동작
        > 헤더에 Connection: keep-alive를 추가하면 커넥션을 끊지 않음 <sup>단, 서버가 응답을 해줘야함</sup>  
          
    4. Keep-Alive 옵션
       > Keep-Alive 헤더는 클라이언트의 희망사항일 뿐 서버가 응답 시 끊어버릴 수 있음  
          > ~~~~
          >  ## 1000개의 트랜잭션을 수행하거나, 5초가 지나면 커넥션을 끊는다
          >  Connection: keep-alive
          >  Keep-Alive: timeout=5, max=1000
          >  ~~~~

    5. Keep-ALive 커넥션 제한과 규칙
       > - 커넥션을 유지하려면, 모든 메시지에 keep-alive를 포함해야 한다
       > - 클라이언트는 서버의 응답에 keep-alive가 없는 것을 보고 커넥션이 끊어짐을 알 수 있다
       > - 엔터티 바디가 있는 응답은 **정확한** Content-Length를 포함해야 한다
       > - 프락시와 게이트웨이는 Connection 해더 규칙을 지킨다
       > - Connection 헤더를 해석 못하는 프락시와는 keep-alive 커넥션을 맺지 않는다
       > - HTTP/1.0 을 따르는 기기로부터 온 Connection 헤더필드는 무시
       > - 클라이언트는 응답 전체를 받기 전에 커넥션이 끊어졌을 경우 문제없을 때 다시 요청을 보내도록 준비되어야한다
       
    6. Keep-Alive와 멍청한 (dumb) 프락시
       > keep-alive 할줄 모르는 프락시가 홉별 헤더를 그대로 전달하면 클라이언트-서버가 타임아웃때까지 기다리게 됨

    7. Proxy-Connection 살펴보기
       > proxy-connection은 영리한 프락시가 Connection으로 수정해서 보내줌  
         그러나 멍청한 프락시랑 같이 있을경우 문제는 여전함

    8. HTTp/1.1의 지속 커넥션
       >  HTTP/1.1은 기본적으로 지속 커넥션을 사용함  
          Connection: close를 명시해야 끊어짐

    9. 지속 커넥션의 제한과 규칙
       > - 서버가 커넥션을 끊고 싶으면 응답에 Connection: close를 포함시킨다.
       > - 클라이언트가 커넥션을 끊고 싶으면 요청에 Connection: close를 포함시킨다.
       > - 모든 메시지가 자신의 길이 정보를 정확하게 가지고 있을 때만 지속 커넥션이 가능하다
       > - HTTP/1.1 프락시는 클라이언트-서버 각각에 대해 별도 지속 커넥션을 관리한다.
       > - HTTP/1.1 프락시는 클라이언트의 커넥션 관련 기능 지원범위를 알고 있지 않으면 지속 커넥션을 맺지 않는다.
       > - HTTP/1.1 기기는 Connection 헤더 값과 상관없이 언제든 커넥션을 끊을 수 있다.
       > - HTTP/1.1 애플리케이션은 중간에 끊어진 커넥션을 복구 할 수 있어야 한다.
       > - 하나의 클라이언트는 서버 부하 방지를 위해 2개정도의 지속 커넥션만을 유지한다.
 
6. 파이파라인 커넥션
7. 커넥션 끊기에 대한 미스터리
    1. '마음대로' 커넥션 끊기
    2. Content-Length와 Truncation
    3. 커넥션 끊기의 허용, 재시도, 멱등성
    4. 우아한 커넥션 끊기
8. 추가 정보
    1. HTTP 커넥션 관련 참고자료
    2. HTTP 성능 이슈 관련 참고자료
    3. TCP/IP 관련 참고자료
