# 7장 캐시

자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.

- 캐시는 불필요한 데이터 전송을 줄여 비용을 절감
- 네트워크 병목을 줄여 대역폭 확보
- 원 서버에 대한 요청을 줄여 부하 감소
- 거리로 인한 지연 시간을 줄여 응답 시간 개선
- 어떻게 캐시가 성능으 ㄹ개선하고 비용을 줄이는가
- 캐시를 어디에 위치시켜야하는가
- 캐시된 사본을 신선하게 유지하는 법
- 캐시의 다른 캐시 혹은 서버와 상호작용

## index

1. 불필요한 데이터 전송
2. 대역폭 병목
3. 갑작스런 요청 쇄도 (Flash Crowds)
4. 거리로 인한 지연
5. 적중과 부적중
    1. 재검사 (Revalidation)
    2. 적중률
    3. 바이트 적중률
    4. 적중과 부적중의 비율
6. 캐시 토폴로지
    1. 개인 전용 캐시
    2. 공용 프락시 캐시
    3. 프락시 캐시 계층들
    4. 캐시망, 콘텐츠 라우팅, 피어링
7. 캐시 처리 단계
    1. 단계 1 : 요청 받기
    2. 단계 2 : 파싱
    3. 단계 3 : 검색
    4. 단계 4 : 신선도 검사
    5. 단계 5 : 응답 생성
    6. 단계 6 : 전송
    7. 단계 7 : 로깅
    8. 캐시 플로 차트
8. 사본을 신선하게 유지하기
    1. 문서 만료
    2. 유효기간과 나이
    3. 서버 재검사
    4. 조건부 메서드와의 재검사
    5. If-Modified-Since: 날짜 재검사
    6. If-None-Match: 엔티티 태그 재검사
    7. 약한 검사기와 강한 검사기
    8. 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
9. 캐시 제어
    1. no-cache와 no-store 응답 헤더
    2. Max-Age 응답 헤더
    3. Expires 응답 헤더
    4. Must-Revalidate 응답 헤더
    5. 휴리스틱 만료
    6. 클라이언트 신선도 제약
    7. 주의할 점
10. 캐시 제어 설정
    1. 아파치로 HTTP 헤더 제어하기
    2. HTTP-EQUM을 통한 HTML 캐시 제어
11. 자세한 알고리즘
    1. 나이와 신선도 수명
    2. 나이 계산
    3. 완전한 나이 계산 알고리즘
    4. 신선도 수명 계산
    5. 완전한 서버 신선도 알고리즘
12. 캐시와 광고
    1. 광고 회사의 딜레마
    2. 퍼블리셔의 응답
    3. 로그 마이그레이션
    4. 적중 측정과 사용량 제한
13. 추가 정보

# Contents

## 1. 불필요한 데이터 전송

불필요한 데이터 전송 : 복수의 클라이언트들이 같은 리소스를 반복해서 요청

### 문제점

- 대역폭 낭비
- 전송속도 저하
- 웹 서버에 부하

### 캐시 사용

- 최초 응답을 캐시에 보관
- 이후 요청에 대해 캐시에서 응답을 반환
- 원서버에 대한 중복 트래픽 감소

## 2. 대역폭 병목

<img src="img.png"  width="50%"/>

- LAN의 대역폭이 원서버와의 대역폭보다 빠름
- LAN에 캐싱한다면 대역폭 속도 이슈 해결 가능

## 3. 갑작스런 요청 쇄도 (Flash Crowds)

<img src="img_1.png"  width="50%"/>

- 갑작스러운 이벤트 <sub>뉴스, 사건 등</sub> 발생 시 원 서버에 대한 요청이 급증
- 일례로, 1998년 9월 11일 클린턴 미대통령 문서가 공개된 미하원 웹서버가 1시간에 3백만건이 넘는 요청을 받음 <sub>평소의 50배</sub>

## 4. 거리로 인한 지연

- 거리가 멀수록 라우터에 의한 지연 발생
- 빛의 속도 자체도 유한하여 지연 유발
- ex. 원서버에 4개의 keep-alive 커넥션을 열고, 20개의 이미지 요청 시, 5배가 소요

## 5. 적중과 부적중

<img src="img_2.png"  width="40%"/>

- 모든 문서를 캐싱하지는 않음 (비용 고려)
- 캐시 적중 <sup>cache hit</sup> : 캐시에 사본이 존재
- 캐시 부적중 <sup>cache miss</sup> : 캐시에 사본이 존재하지 않아 원서버에 요청

### 5.1 재검사 (Revalidation)

- 신선도 검사라고도 함
- 캐시 데이터가 최신인지 원서버를 통해 검사하는 것

#### 효과적인 재검사를 위한 특별한 요청

<img src="img_3.png"  width="40%"/>

- 대역폭을 고려 대부분의 캐시는 사본을 검사할 필요가 있을정도로 오래된 경우에만 재검사 실시
- 신선도 검사 규칙 존재
- 재검사 적중 <sup>느린 적중, revalidate hit, slow hit</sup>
    - 재검사시 원서버에 아주 작은 요청을 보냄
    - 서버는 변경되지 않았으면 304 Not Modified 응답
    - 캐시에 신선하다는 임시 표시한 뒤 클라이언트에게 응답
    - 원 서버와의 통신시간이 있어 순수 캐시 적중보다는 느림
    - 캐시 부적중보다는 빠름 <sub>원 서버로부터 객체 데이터를 안받아도 됨</sub>

#### If-Modified-Since 헤더

##### 예시

```
If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
```

<img src="img_4.png"  width="40%"/>

- 신선도 검사를 하기 위해 가장 많이 쓰이는 도구
- Get, Head 요청에 사용 가능
- 헤더 값 이후에 수정된 경우에는 객체를 반환하라는 의미
- 세가지 시나리오 존재
    - revalidate hit : 304 Not Modified, 데이터가 수정되지 않아서 캐시 사용 가능
    - revalidate miss : 200 OK, 데이터가 수정되어서 캐시 사용 불가, 객체 응답
    - Object deleted : 404 Not Found, 객체가 삭제되어서 캐시 사용 불가

### 5.2 적중률 <sup>Hit Rate</sup>

- 캐시가 처리하는 비율
- 캐시 적중률, 캐시 적중비라고도 함
- %로 표현
    - ex. 캐시 적중률 0% : 모든 요청이 캐시 부적중

#### 적중률에 영향을 미치는 요소

- 캐시의 크기
- 캐시 사용자들의 관심사 비슷 정도
- 캐시된 데이터의 수정 빈도, 개인화 정도
- 캐시 설정 수준
- 40%면 괜찮은 수준

### 5.3 바이트 적중률 <sup>Byte Hit Rate</sup>

- 문서마다 크기가 다름
- 단순 적중률 보다 바이트 단위 적중률을 더 선호
    - 특히, 트래픽의 바이트에 대한 비용 청구를 고려하기 떄문
- ex. 바이트 적중률 100% : 모든 바이트가 캐시로부터 제공됨

#### 문서 적중률 vs 바이트 적중률

- 문서 적중률
    - 웹 트랜잭션의 개수 측면에서 캐시 성능 측정
    - TCP hand shake 와 같이 고정된 시간이 트랜잭션 수에 영향 <sub>트랝개션 많음 -> 핸드셰이크 시간 많음</sub>
    - 문서 적중률 개선 시 전체 지연 시간이 줄어듦
- 바이트 적중률
    - 얼마나 많은 바이트가 원서버에서 나가지 않았는지 측정
    - 대역폭 절약 최적화

### 5.4 적중과 부적중의 비율

- HTTP는 캐시 데이터인지, 원 서버 데이터인지 구분해주지 않음
    - 둘 다 200 OK 응답
- Date 헤더
    - 응답 메시지 생성 일시
    - 응답 생성일이 오래되었다면 캐시인 것으로 간주
- Age 헤더 : 프록시 캐시네에 머문 시간

## 6. 캐시 토폴로지 <sup>Topologies</sup>

<img src="img_5.png"  width="40%"/>

- private cache <sup>개인 전용 캐시</sup> : 하나의 클라이언트에게만 할당된 캐시
- public cache <sup>public proxy cache ,공용 캐시</sup> : 여러 클라이언트에게 할당된 캐시

### 6.1 개인 전용 캐시 <sup>Private Caches</sup>

- 많은 에너지, 저장공간 필요 없음
- 작고 저렴
- 웹 브라우저의 개인 전용 캐시
    - 자주쓰는 문서를 PC 디스크, 메모리에 캐시
    - 인터넷 브라우저 화면에서 캐시 확인 가능

### 6.2 공용 프록시 캐시 <sup>Public Proxy Caches</sup>

<img src="img_6.png"  width="50%"/>

- 프락시 서버의 일종
- 자주 찾는 객체를 단 한번으 캐싱으로 전체 트래픽 감소
- 기본적인 프락시 설정에 따름
    - [수동 설정](../6장_프락시/README.md#41-클라이언트-프락시-설정--수동) : 브라우저가 프락시 캐시를 사용하게 함
    - 인터셉트 프락시 : 브라우저 설정 없이 HTTP 요청을 캐시로 통하도록 강제

### 6.3 프락시 캐시 계층들

<img src="img_7.png"  width="50%"/>

- 캐시 프락시를 계층형으로 구성
- 아래 단계에서 캐시 북적중이 발생하면 위 단계에서 캐시 적중을 발생시켜 트래픽 감소시킴
- 클라이언트 주위에는 작고 저렴한 캐시 배치
- 상단에는 다수의 사용자와 공유하는 캐시 배치

### 6.4 캐시망 <sup>Cache Meshes</sup>, 콘텐츠 라우팅, 피어링

<img src="img_8.png"  width="50%"/>

#### 캐시망

- 복잡한 방법으로 서로 대화
- 부모 캐시 대상 선택, 원서버 요청 등을 동적으로 결정
- sibling caches <sup>형제 캐시</sup> : 선택적인 피어링을 지원하는 캐시
- 서로 다른 조직들이 그들의 캐시를 피어링 <sub>서로 캐시를 찾아보게 허용</sub>

#### 캐시망 안에서의 콘텐츠 라우팅

- URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
- URL에 근거하여 특정 부모 캐시 동적 선택
- 부모 캐시에 가기 전, 로컬 캐시에서 탐색
- 다른 캐시들이 캐시 컨텐츠에 부분적 접근을 허용하되, 캐시를 통한 internet transit 비허용

