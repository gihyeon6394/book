# 10장 HTTP 2.0

1. HTTP/2.0의 등장 배경
2. 개요
3. HTTP/1.1과의 차이점
4. 알려진 보안 이슈
5. 추가 정보

---

- HTTP의 성능 문제를 개선하기 위함
- 8번째 초안 기준 설명

## 1. HTTP/2.0의 등장 배경

- HTTP/1.1의 메시지 포맷은 구현 단순성, 접근성에 주안을 두고 최적화
- 성능은 희생
- 커넥션 하나를 통해 HTTP 메시지 교환
- latency : 응답이 와야 다음 요청을 보낼 수 있음
- Roy Fielding이 WAKA 프로젝트 제안
- MS가 S+M 프로토콜 개발
- 구글이 SPDY 프로토콜 개발
    - 헤더를 압축하여 대역폭 절약
    - 클라이언트 요청이 없어도 서버가 능동적으로 리소스 푸시

## 2. 개요

- 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작
- 클라이언트가 TCP 커넥션 초기화
- 요청/응답은 16,383 bytes 한개 이상의 프레임에 담김
    - HTTP 헤더는 압축
- 프레임에 담긴 요청/응답 은 스트림으로 보내짐
- 한개의 스트림이 한쌍의 요청/응답을 처리
- 하나의 커넥션 위에 여러 스트림 만들어짐 (=여러개의 요청/응답을 처리 가능)
- 스트림에 대한 흐름제어/우선순위 부여 가능
- 서버 푸시 : 클라이언트 요청 없이 서버가 능동적으로 리소스 푸시 가능
- `Content-Length` -> `:content-length`
- `404 Not Found` -> `:status` 헤더 사용

## 3. HTTP/1.1과의 차이점

### 3.1 프레임

- 모든 메시지는 프레임에 담김
- 8 bytes 헤더 + 16,383 bytes payload
- Frame header
    - `R` : reserved 2 bits
        - 값의 의미 없음, 반드시 0, 받는 쪽에서는 무시
    - 길이 : payload의 길이를 나타내는 무부호 정수
    - 종류 : 프레임 종류
    - 플래그 : 8 bits flag, 프레임 종류에 따라 값의 의미 다름
    - `R` : reserved 1 bit
        - 값의 의미 없음, 반드시 0, 받는 쪽에서는 무시
    - 스트림 식별자 : 31 bits
        - 0은 커넥션 전체와 연관된 프레임을 뜻함
- FRAME 종류는 총 10가지
    - DATA, HEADERS, PRIORITY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION

### 3.2 스트림과 멀티플렉싱

- 스트림 : HTTP/2.0을 통해 클라이언트/서버 사이에 교환되는 양방향 시퀀스
- 한쌍의 HTTP 요청/응답은 하나의 스트림을 통해 교환
    - 클라이언트가 스트림 생성 후 요청을 보내면 서버가 응답을 보내고 스트림을 닫음
- 하나의 커넥션에 여러 스트림이 동시에 열릴 수 있음
    - 하나의 HTTP/2.0 커넥션에서 여러 요청을 동시에 보낼 수 있음
- 스트림 우선순위
    - e.g. 대역폭이 모자라면 웹 브라우저에서 더 중요한 리소스 요청 스트림에 더 높은 우선순위 부여 가능
- 스트림의 31 bits 무부호 정수 고유 식별자
    - 홀수 : 클라이언트가 스트림 초기화
    - 짝수 : 서버가 스트림 초기화
    - 이전에 만들어진 식별자보다 반드시 커야함
- 스트림은 상대와 협상없이 일방적으로 만듦
    - TCP handshake와 같은 협상 과정이 없음
- 한번 사용한 스트림 재사용 불가능

### 3.3 헤더 압축

- HTTP/1.1은 헤더의 압축없이 그대로 전송
- 요즘에는 웹페이지 하나의 요청에 헤더의 크기가 큰편
    - 헤더의 크기가 latency, 대역폭에 영향
- HTTP/2.0은 헤더 압축
- HPACK 명세에 정의된 압축방법으로 헤더 블록 조각들을 쪼개어 전송
    - 받는 쪽에서는 조각들을 합쳐 압축을 풀고 헤더 복원

### 3.4 서버 푸시

- 서버가 하나의 요청에 대한 응답으로 여러 리소스 보내기 가능
- e.g. HTML 요청에 대해 응답으로 이미지, css, js 파일 등을 응답

1. 서버는 클라이언트에게 PUSH_PROMISE 프레임을 보내어 푸시를 미리 알림
2. 클라이언트는 PUSH_PROMISE 프레임을 받음
3. 스트림은 에약됨 상태가 됨
4. 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절 가능 (스트림이 즉각 닫힘)

#### 주의사항

- 서버 푸시를 사용해도 중간에 프락시가 리소스를 클라이언트에게 전달 안했을 수 있음
- 서버는 오직 안전, 캐시 가능, 본문이 없는 요청에 대해서만 푸시 가능
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야함
- 서버의 PUSH_PROMISE 프레임은 클라이언트의 원요청 스트림에 대한 응답으로 보내짐
- 클라이언트는 반드시 서버의 푸시 리소스를 Same-Origin Policy에 따라 검사해야함
- SETTINGS_ENABLE_PUSH 설정을 통해 서버 푸시를 사용하지 않도록 설정 가능

## 4. 알려진 보안 이슈

### 4.1 중개자 캡슐화 공격 (Intermediary Encapsulation Attack)

- HTTP/2.0 메시지를 프락시가 HTTP/1.1 메시지로 변환할 때 발생
- HTTP/2.0 헤더 필드는 어떤 문자열이든 가능
- HTTP/1.1 로 변환 시 위/변조 된 메시지로 번역될 가능성이 있음

### 4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

- HTTP/2.0은 하나의 커넥션을 오래 유지하는 것을 염두에 둠
- e.g. 사용자가 브라우저 사용시 이전 브라우저 사용자의 사용 정보를 알아낼 수 있음

